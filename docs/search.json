[
  {
    "objectID": "envir.html",
    "href": "envir.html",
    "title": "3  Environment",
    "section": "",
    "text": "In this section we will prepare the environment for further analysis. Concourse parameters: width(x) = 53, height(y) = 50;"
  },
  {
    "objectID": "envir.html#global",
    "href": "envir.html#global",
    "title": "3  Environment",
    "section": "3.1 Global",
    "text": "3.1 Global\n\n# First let's define an area in metres\ngcs_env_m = function(){\n  plot((-250 /14):(900/14), (-250/14):(900/14), col = \"white\", xlab = \"X\", ylab = \"Y\") # draw an empty plot\n  polygon(x = c(0, 0, 740/14, 740/14),\n          y = c(0, 700/14, 700/14, 0),\n          border = \"blue\",\n          lwd = 2) # draw walls of a GCS\n  polygon(x= c(-150/14, 0, 0, -150/14),\n          y = c(400/14, 400/14, 150/14, 150/14),\n          border = \"blue\",\n          lwd = 2) # exit 0\n  polygon(x = c(0, 250/14, 250/14, 0),\n          y = c(850/14, 850/14, 700/14, 700/14),\n          border = \"red\",\n          lwd = 2) # exit 1\n  polygon(x = c(455/14, 700/14, 700/14, 455/14),\n          y = c(850/14, 850/14, 700/14, 700/14),\n          border = \"red\",\n          lwd = 2) # exit 2\n  polygon(x = c(740/14, 860/14, 860/14, 740/14),\n          y = c(700/14, 700/14, 610/14, 610/14),\n          border = \"red\",\n          lwd = 2) # exit 3\n  polygon(x = c(740/14, 860/14, 860/14, 740/14),\n          y = c(550/14, 550/14, 400/14, 400/14),\n          border = \"red\",\n          lwd = 2) # exit 4\n  polygon(x = c(740/14, 860/14, 860/14, 740/14),\n          y = c(340/14, 340/14, 190/14, 190/14),\n          border = \"red\",\n          lwd = 2) # exit 5\n  polygon(x = c(740/14, 860/14, 860/14, 740/14),\n          y = c(130/14, 130/14, 0, 0),\n          border = \"red\",\n          lwd = 2) # exit 6\n  polygon(x = c(555/14, 740/14, 740/14, 555/14),\n          y = c(0, 0, -70/14, -70/14),\n          border = \"red\",\n          lwd = 2) # exit 7\n  polygon(x = c(370/14, 555/14, 556/14, 370/14),\n          y = c(0, 0, -70/14, -70/14),\n          border = \"red\",\n          lwd = 2) # exit 8\n  polygon(x = c(185/14, 370/14, 370/14, 185/14),\n          y = c(0, 0, -70/14, -70/14),\n          border = \"red\",\n          lwd = 2) # exit 9\n  polygon(x = c(0, 185/14, 185/14, 0),\n          y = c(0, 0, -70/14, -70/14),\n          border = \"red\",\n          lwd = 2) # exit 10\n  # polygon(x = c(294, 252, 210, 210, 252, 294, 336, 336, 294),\n  #         y = c(294, 294, 336, 378, 420, 420, 378, 336, 294),\n  #         col = \"red\") # information booth (an obstacle)\n  plotrix::draw.circle(x = 371/14, y = 280/14, \n                       radius = 56/14, \n                       col = \"red\") # obstacle \n  # annotation of a plot\n  text(x = -84/14,\n       y = 252/14,\n       label = \"Exit 0\",\n       srt = 90)\n  text(x = 112/14,\n       y = 770/14,\n       label = \"Exit 1\")\n  text(x = 560/14,\n       y = 770/14,\n       label = \"Exit 2\")\n  text(x = 784/14,\n       y = 630/14,\n       label = \"Exit 3\",\n       srt = -90)\n  text(x = 784/14,\n       y = 455/14,\n       label = \"Exit 4\",\n       srt = -90)\n  text(x = 784/14,\n       y = 252/14,\n       label = \"Exit 5\",\n       srt = -90)\n  text(x = 784/14, \n       y = 42/14,\n       label = \"Exit 6\",\n       srt = -90)\n  text(x = 630/14,\n       y = -49/14,\n       label = \"Exit 7\")\n  text(x = 448/14,\n       y = -49/14,\n       label = \"Exit 8\")\n  text(x = 266/14, \n       y = -49/14,\n       label = \"Exit 9\")\n  text(x = 63/14,\n       y = -49/14,\n       label = \"Exit 10\")\n}\ngcs_env_m()\n\n\n\n# now, let's convert the env into an sf object\nmatrix_walls = matrix(c(0,0,0,50,53,50, 53,0,0,0),\n                      ncol = 2,\n                      byrow = TRUE)\nmatrixlist_walls = list(matrix_walls)\npolygon_walls = sf::st_polygon(matrixlist_walls)\n\n# calculate area size (will be needed for measuring density)\ngcs_area = polygon_walls |> sf::st_area()"
  },
  {
    "objectID": "envir.html#divided",
    "href": "envir.html#divided",
    "title": "3  Environment",
    "section": "3.2 Divided",
    "text": "3.2 Divided\n\n# divide gcs polygon by creating a grid\ngcs_div = sf::st_make_grid(polygon_walls, \n                           n = 2,\n                           what = \"polygons\")\n\n# convert gcs_div to an sf object\ngcs_div_sf = gcs_div |> \n  sf::st_as_sf() |> \n  dplyr::rename(geom = x)\n\n# find out the area size of each polygon\ngcs_area_div = list()\nfor (i in 1:lengths(gcs_div_sf)){\n  gcs_area_div[[i]] = sf::st_area(gcs_div_sf[[i]]) \n  # print(gcs_area_div)\n}\n# make it a vector\ngcs_area_div = gcs_area_div |>\n  unlist() |>\n  as.vector()\n\n\ngcs_env_m()\ngcs_div_sf |> plot(add = T)\ngcs_div_sf[1,] |> plot(add = T, col = \"yellow\")\ngcs_div_sf[2,] |> plot(add = T, col = \"green\")\ngcs_div_sf[3,] |> plot(add = T, col = \"purple\")\ntext(x = 15,\n       y = 15,\n       label = \"polygon 1\")\ntext(x = 40,\n       y = 15,\n       label = \"polygon 2\")\ntext(x = 15,\n       y = 40,\n       label = \"polygon 3\")\ntext(x = 40,\n       y = 40,\n       label = \"polygon 4\")"
  },
  {
    "objectID": "envir.html#selected",
    "href": "envir.html#selected",
    "title": "3  Environment",
    "section": "3.3 Selected",
    "text": "3.3 Selected\nTwo areas have been selected based on the results of the previous work: https://github.com/Urban-Analytics/uncertainty/blob/master/gcs/process.ipynb Hence, it’s zone 1 (exit 0) and zone 2 (around exit 5) One cell is 2x2, each zone is 5 (width) and 6 (length) cells, thus 10 and 12 metres accordingly\nZone 1 is next to exit 0, thus its length has been left equal to the length of the gates. The width has been approximated to 10 metres (1 pixel = 2 metres).\nZone 2 is on the opposite side to Zone 1 and is 1 pixel below comapred to Zone 1, thus around exit 5.\n\n## zone 1 (it's next to exit 0)\ngcs_env_m()\npolygon(x = c(10, 0, 0, 10),\n        y = c(28, 28, 10, 10),\n        border = \"blue\",\n        lwd = 2)\n\n## zone 2\n# gcs_env_m()\npolygon(x = c(53, 43, 43, 53),\n        y = c(26, 26, 8, 8),\n        border = \"blue\",\n        lwd = 2)\n\n# zone 1 sf polygon\nzone1_matrix = matrix(c(10, 28, 0, 28, 0, 10, 10, 10, 10, 28),\n                      ncol = 2,\n                      byrow = T)\nzone1_matrix_list = list(zone1_matrix)\nzone1 = sf::st_polygon(zone1_matrix_list)\n\n# zone 2 sf polygon\nzone2_matrix = matrix(c(53, 26, 43, 26, 43, 8, 53, 8, 53, 26),\n                      ncol = 2,\n                      byrow = T)\nzone2_matrix_list = list(zone2_matrix)\nzone2 = sf::st_polygon(zone2_matrix_list)\n\n# checking where selected areas are\ngcs_env_m()\nzone1 |> plot(add = T, border = \"green\", lwd = 2)\nzone2 |> plot(add = T, border = \"green\", lwd = 2)\n\n# join both zones\nzones = list(zone1, zone2)\n\n# find out the area size of each polygon\ngcs_area_sel = list()\nfor (i in 1:length(zones)){\n  gcs_area_sel[[i]] = sf::st_area(zones[[i]]) \n  # print(gcs_area_div)\n}\n# make it a vector\ngcs_area_sel = gcs_area_sel |>\n  unlist() |>\n  as.vector()\n\n\ngcs_env_m()\nzones[[1]] |> plot(add = T, col = \"green\")\nzones[[2]] |> plot(add = T, col = \"yellow\")\ntext(x = 10,\n     y = 20,\n     label = \"Zone 1\")\ntext(x = 45,\n     y = 20,\n     label = \"Zone 2\")"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "8  Summary",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Getting data",
    "section": "",
    "text": "# let's convert jps and gcs dataframes to sf objects, so we can perform spatial operations\n\ntraj1_sf = traj1 |> \n  sf::st_as_sf(coords = c(\"X\", \"Y\")) |> \n  dplyr::select(-c(3,4,5,6,7)) # drop columns we won't need\n\ngcs_sf = gcs |> \n  sf::st_as_sf(coords = c(\"x_coord\", \"y_coord\")) |> \n  dplyr::mutate(geometry = geometry/14) # convert from pixels to metres"
  },
  {
    "objectID": "flow.html",
    "href": "flow.html",
    "title": "4  Flow",
    "section": "",
    "text": "Flow is one of the basic measures to quantify pedestrian dynamics (Steffen and Seyfried, 2010).\nFlow is measured by counting the heads that pass through a line, e.g. doors, within a given time interval.\nIn this chapter we will find out three types of flow in Grand Central Station (GCS) and JuPedSim (JPS) model:"
  },
  {
    "objectID": "flow.html#divided-flow-gcs",
    "href": "flow.html#divided-flow-gcs",
    "title": "4  Flow",
    "section": "4.2 2.1 Divided flow (GCS)",
    "text": "4.2 2.1 Divided flow (GCS)\n\n# first create a list to store our multiple dataframes\ngcs_joined = list()\nfor (i in 1:lengths(gcs_div_sf)){\n  gcs_joined[[i]] = gcs_sf_s[gcs_div_sf[i,], op = sf::st_intersects] # all intersecting points will be selected\n}\n\n# sanity check\ngcs_joined1 = gcs_sf_s[gcs_div_sf[1,], op = sf::st_intersects]\ngcs_joined2 = gcs_sf_s[gcs_div_sf[2,], op = sf::st_intersects]\nidentical(gcs_joined1, gcs_joined[[1]]) # TRUE\nidentical(gcs_joined2, gcs_joined[[2]]) # TRUE\n\n\n# group each sf object by seconds and make a list out of them\ngcs_joined_grouped = list()\nfor (i in 1:length(gcs_joined)){\n  gcs_joined_grouped[[i]] = gcs_joined[[i]] |> \n    sf::st_drop_geometry() |> \n    dplyr::group_by(sec) |> \n    dplyr::summarise(n = dplyr::n())\n}\n\n# sanity check comparison (alert: ugly code!)\nidentical(gcs_joined_grouped[[1]], # first list of a list that was just made\n          gcs_joined[[1]] |> # repeating the same code as in the loop above but only on 1 (the first) list \n            sf::st_drop_geometry() |> \n            dplyr::group_by(sec) |> \n            dplyr::summarise(n = dplyr::n()))\n\n\n4.2.1 Plotting\nIn the plot showing flow in the entire GCS environment, I added means and medians but this time I will exclude them as I do not know if it’s valuable to have them at this stage. Plus, it will make the code shorter.\n\n# let's create a list of plots showing flow in each polygon\ngcs_flow_div_plots = list()\nfor (i in 1:length(gcs_joined_grouped)){\n  gcs_flow_div_plots[[i]] = ggplot2::ggplot(gcs_joined_grouped[[i]]) +\n    ggplot2::aes(x = sec,\n                 y = n) +\n    ggplot2::geom_line() \n  # print(gcs_flow_div_plots)\n}\n\n\n# let's plot a polygons 1-4 \ngridExtra::grid.arrange(gcs_flow_div_plots[[1]], gcs_flow_div_plots[[2]],gcs_flow_div_plots[[3]],gcs_flow_div_plots[[4]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "flow.html#selected-gcs",
    "href": "flow.html#selected-gcs",
    "title": "4  Flow",
    "section": "4.3 3.1 Selected (GCS)",
    "text": "4.3 3.1 Selected (GCS)\n\n# a list to store our 2 dataframes for the selected areas\ngcs_joined_zones = list()\nfor (i in 1:length(zones)){\n  gcs_joined_zones[[i]] = gcs_sf_s[zones[[i]], op = sf::st_intersects] # all intersecting points will be selected\n}\n\n# sanity check\ngcs_joined_zones1 = gcs_sf_s[zones[[1]], op = sf::st_intersects]\nidentical(gcs_joined_zones1, gcs_joined_zones[[1]]) # TRUE\n\n\n# group each sf object by seconds and make a list out of them\ngcs_joined_grouped_zones = list()\nfor (i in 1:length(gcs_joined_zones)){\n  gcs_joined_grouped_zones[[i]] = gcs_joined_zones[[i]] |> \n    sf::st_drop_geometry() |> \n    dplyr::group_by(sec) |> \n    dplyr::summarise(n = dplyr::n())\n}\n\n# sanity check comparison (alert: ugly code!)\nidentical(gcs_joined_grouped_zones[[1]], # first list of a list that was just made\n          gcs_joined_zones[[1]] |> # repeating the same code as in the loop above but only on 1 (the first) list \n            sf::st_drop_geometry() |> \n            dplyr::group_by(sec) |> \n            dplyr::summarise(n = dplyr::n()))\n\n\n4.3.1 Plotting\n\n# let's create a list of plots showing flow in each polygon\ngcs_flow_zones_plots = list()\nfor (i in 1:length(gcs_joined_grouped_zones)){\n  gcs_flow_zones_plots[[i]] = ggplot2::ggplot(gcs_joined_grouped_zones[[i]]) +\n    ggplot2::aes(x = sec,\n                 y = n) +\n    ggplot2::geom_line() \n  # print(gcs_flow_zones_plots )\n}\n\ngridExtra::grid.arrange(gcs_flow_zones_plots[[1]], gcs_flow_zones_plots[[2]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "gcs_jps",
    "section": "",
    "text": "0.0.2 Bibliography\nAndrew Crooks, Alison Heppenstall, Nick Malleson, and Ed Manley. 2021. “Agent-Based Modeling and the City: A Gallery of Applications.” In Urban Informatics, edited by Wenzhong Shi, Michael F. Goodchild, Michael Batty, Mei-Po Kwan, and Anshu Zhang, 885–910. The Urban Book Series. Singapore: Springer. https://doi.org/10.1007/978-981-15-8983-6_46.\nLe-Minh Kieu, Nicolas Malleson, and Alison Heppenstall. 2020. “Dealing with Uncertainty in Agent-Based Models for Short-Term Predictions.” Royal Society Open Science 7 (1). https://doi.org/10.1098/rsos.191074.\nPaul M Torrens. 2010. “Agent-Based Models and the Spatial Sciences.” Geography Compass 4 (5): 428–48. https://doi.org/10.1111/j.1749-8198.2009.00311.x."
  },
  {
    "objectID": "flow.html#global-jps",
    "href": "flow.html#global-jps",
    "title": "4  Flow",
    "section": "4.4 1.2 Global (JPS)",
    "text": "4.4 1.2 Global (JPS)\n\n# now let's create a new column for seconds\n# 1 second = 25 frames\njps_s = traj1_sf |> \n  dplyr::mutate(sec = FR / 25)\n\n# group df by seconds\njps_grouped = jps_s |> \n  sf::st_drop_geometry() |> #drop geometry as it's not needed here\n  dplyr::group_by(sec) |> # group by seconds\n  dplyr::summarise(n = dplyr::n()) # summarise \n\njps_grouped |> \n  head()\n\n\n4.4.1 Plotting\n\njps_flow_plot = ggplot2::ggplot(jps_grouped) +\n  ggplot2::aes(x = sec,\n               y = n) +\n  ggplot2::geom_line()\njps_flow_plot"
  },
  {
    "objectID": "flow.html#divided-flow-jps",
    "href": "flow.html#divided-flow-jps",
    "title": "4  Flow",
    "section": "4.5 2.2 Divided flow (JPS)",
    "text": "4.5 2.2 Divided flow (JPS)\n\n# first create a list to store our multiple dataframes\njps_joined = list()\nfor (i in 1:lengths(gcs_div_sf)){\n  jps_joined[[i]] = jps_s[gcs_div_sf[i,], op = sf::st_intersects] # all intersecting points will be selected\n}\n\n# sanity check\njps_joined1 = jps_s[gcs_div_sf[1,], op = sf::st_intersects]\nidentical(jps_joined1, jps_joined[[1]]) # TRUE\n\n\n# group each sf object by seconds and make a list out of them\njps_joined_grouped = list()\nfor (i in 1:length(jps_joined)){\n  jps_joined_grouped[[i]] = jps_joined[[i]] |> \n    sf::st_drop_geometry() |> \n    dplyr::group_by(sec) |> \n    dplyr::summarise(n = dplyr::n())\n}\n\n# sanity check comparison (alert: ugly code!)\nidentical(jps_joined_grouped[[1]], # first list of a list that was just made\n          jps_joined[[1]] |> # repeating the same code as in the loop above but only on 1 (the first) list \n            sf::st_drop_geometry() |> \n            dplyr::group_by(sec) |> \n            dplyr::summarise(n = dplyr::n()))\n\n\n4.5.1 Plotting\n\n# let's create a list of plots showing flow in each polygon\njps_flow_div_plots = list()\nfor (i in 1:length(jps_joined_grouped)){\n  jps_flow_div_plots[[i]] = ggplot2::ggplot(jps_joined_grouped[[i]]) +\n    ggplot2::aes(x = sec,\n                 y = n) +\n    ggplot2::geom_line() \n  # print(gcs_flow_div_plots)\n}\n\n\n# let's plot polygons 1-4 \ngridExtra::grid.arrange(jps_flow_div_plots[[1]], jps_flow_div_plots[[2]],jps_flow_div_plots[[3]],jps_flow_div_plots[[4]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "flow.html#selected-jps",
    "href": "flow.html#selected-jps",
    "title": "4  Flow",
    "section": "4.6 3.2 Selected (JPS)",
    "text": "4.6 3.2 Selected (JPS)\n\n# a list to store our 2 dataframes for the selected areas\njps_joined_zones = list()\nfor (i in 1:length(zones)){\n  jps_joined_zones[[i]] = jps_s[zones[[i]], op = sf::st_intersects] # all intersecting points will be selected\n}\n\n# sanity check\njps_joined_zones1 = jps_s[zones[[1]], op = sf::st_intersects]\nidentical(jps_joined_zones1, jps_joined_zones[[1]]) # TRUE\n\n\n# group each sf object by seconds and make a list out of them\njps_joined_grouped_zones = list()\nfor (i in 1:length(jps_joined_zones)){\n  jps_joined_grouped_zones[[i]] = jps_joined_zones[[i]] |> \n    sf::st_drop_geometry() |> \n    dplyr::group_by(sec) |> \n    dplyr::summarise(n = dplyr::n())\n}\n\n# sanity check comparison (alert: ugly code!)\nidentical(jps_joined_grouped_zones[[1]], # first list of a list that was just made\n          jps_joined_zones[[1]] |> # repeating the same code as in the loop above but only on 1 (the first) list \n            sf::st_drop_geometry() |> \n            dplyr::group_by(sec) |> \n            dplyr::summarise(n = dplyr::n()))\n\n\n4.6.1 Plotting\n\n# let's create a list of plots showing flow in each polygon\njps_flow_zones_plots = list()\nfor (i in 1:length(jps_joined_grouped_zones)){\n  jps_flow_zones_plots[[i]] = ggplot2::ggplot(jps_joined_grouped_zones[[i]]) +\n    ggplot2::aes(x = sec,\n                 y = n) +\n    ggplot2::geom_line() \n  # print(gcs_flow_zones_plots )\n}\n\ngridExtra::grid.arrange(jps_flow_zones_plots[[1]], jps_flow_zones_plots[[2]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "flow.html#comparison",
    "href": "flow.html#comparison",
    "title": "4  Flow",
    "section": "4.7 Comparison",
    "text": "4.7 Comparison\nIn this subsection we will overlay GCS and JPS plots to compare flows.\n\n4.7.1 Global\n\nflow_comp = gcs_flow_plot\n  ggplot2::geom_line(data = jps_grouped,\n                     color = \"red\")\n\n\n\n\nGlobal Flow\n\n\n\n\n4.7.2 Divided\n\nflow_div_comp = list()\nfor (i in 1:length(gcs_flow_div_plots)) {\n  flow_div_comp[[i]] = gcs_flow_div_plots[[i]] + \n  ggplot2::geom_line(data = jps_joined_grouped[[i]],\n                     color = \"red\")\n}\n\ngridExtra::grid.arrange(flow_div_comp[[1]], flow_div_comp[[2]],flow_div_comp[[3]],flow_div_comp[[4]], layout_matrix = rbind(c(1,2),c(3,4)))\n\n\n\n\nDivided Flow\n\n\n\n\n4.7.3 Selected\n\nflow_sel_comp = list()\nfor (i in 1:length(gcs_flow_zones_plots)) {\n  flow_sel_comp[[i]] = gcs_flow_zones_plots[[i]] + \n  ggplot2::geom_line(data = jps_joined_grouped_zones[[i]],\n                     color = \"red\")\n}\n\ngridExtra::grid.arrange(flow_sel_comp[[1]], flow_sel_comp[[2]], layout_matrix = rbind(c(1,2)))\n\n ## Discussion\nJPS model (simulated data) has higher flow rate compared to GCS (real data) in all plots. A potential reason for this is that in the JPS model new agents are “injected” into the environement at defined periods of time, which might not be representative of the actual pedestrian dynamics in the concourse. In other words, it is likely that in the real life pedestrians enter and exit the environment based on the train schedule, thus ensuring more or less stable in and out-flow rates. This might not be captured in the model, thus resulting in a peak that is not present in the GCS data.\nImportantly, however, we can see that in the plots representing the flow in the selected areas (Zone 1 and 2) the rate is what was expected: Zone 1 is has lower agent flow compared to Zone 2. In this respect the JPS model seems pretty well calibrated even if, in tota, it has higher flow rate."
  },
  {
    "objectID": "density.html",
    "href": "density.html",
    "title": "5  Density",
    "section": "",
    "text": "Density measure is similar to flow, but instead of countin the number of agents passing through, for instance, gates, persons per area are measured. Thus, its function is:\nDensity = N / m2\nN = number of agents\nSteffen and Seyfried (2010) identify two issues with this density measure:\nTo address these issues, authors suggest implementing Voronoi diagrams. This will be done in the “Voronoi” chapter of this report.\nBefore moving on, I assume that density plots will resemble flow plots as both of them rely on the number of agents passing through a given area/line, but in density measure the flow rate is divided by an area (m2) of a measured area. Theoretically, if an area is 1m2x1m2 then the flow and density plots would overlap."
  },
  {
    "objectID": "density.html#global-gcs",
    "href": "density.html#global-gcs",
    "title": "5  Density",
    "section": "5.1 1.1 Global (GCS)",
    "text": "5.1 1.1 Global (GCS)\n\n# group by seconds and then measure density\ngcs_d = gcs_sf |> \n  sf::st_drop_geometry() |> \n  dplyr::mutate(sec = as.numeric(frame)/25) |>  # 1 sec = 25 frames\n  dplyr::group_by(sec) |> \n  dplyr::summarise(n = dplyr::n(),\n                   frame = frame) |> \n  dplyr::mutate(\n    density = n / gcs_area \n  )\n\ngcs_d |> head()\n\n\n5.1.1 Plotting\n\ngcs_density = ggplot2::ggplot(gcs_d)+\n  ggplot2::aes(x = sec,\n               y = density)+\n  ggplot2::geom_line()\n\nprint(gcs_density)\n\nDensity plot looks exactly the same as flow plot.\n\nggplot2::ggplot(gcs_d)+\n  ggplot2::aes(x = sec,\n               y = density)+\n  ggplot2::geom_line() +\n  ggplot2::geom_line(data = gcs_d,\n                     ggplot2::aes(x = sec,\n                                  y = n),\n                     col = \"red\")"
  },
  {
    "objectID": "density.html#divided-gcs-density",
    "href": "density.html#divided-gcs-density",
    "title": "5  Density",
    "section": "5.2 1.2 Divided GCS density",
    "text": "5.2 1.2 Divided GCS density\n\n# add area as a new column\ngcs_den_div = list()\nfor (i in 1:length(gcs_joined_grouped)){\n  gcs_den_div[[i]] = gcs_joined_grouped[[i]] |> dplyr::mutate(area = gcs_area_div[i])\n}\n\n\n# find density for each group in each list\ngcs_d_div = list()\nfor (i in 1:length(gcs_area_div)){\n  gcs_d_div[[i]] = gcs_den_div[[i]] |> dplyr::mutate(density = n / gcs_area_div[i])\n}\n\n\n5.2.1 Plotting\n\ngcs_den_plots = list()\nfor (i in 1:length(gcs_d_div)){\n  gcs_den_plots[[i]] = ggplot2::ggplot(gcs_d_div[[i]]) +\n    ggplot2::aes(x = sec,\n                 y = density) +\n    ggplot2::geom_line() \n}\n\n# let's plot a polygons 1-4 and 5-8\ngridExtra::grid.arrange(gcs_den_plots[[1]], gcs_den_plots[[2]], gcs_den_plots[[3]], gcs_den_plots[[4]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "density.html#selected-gcs",
    "href": "density.html#selected-gcs",
    "title": "5  Density",
    "section": "5.3 1.3 Selected (GCS)",
    "text": "5.3 1.3 Selected (GCS)\n\n# add area as a new column\ngcs_den_sel = list()\nfor (i in 1:length(gcs_joined_zones)){\n  gcs_den_sel[[i]] = gcs_joined_grouped_zones[[i]] |> dplyr::mutate(area = gcs_area_sel[i])\n}\n\n\n# find density for each group in each list\ngcs_d_sel = list()\nfor (i in 1:length(gcs_joined_zones)){\n  gcs_d_sel[[i]] = gcs_den_sel[[i]] |> dplyr::mutate(density = n / gcs_area_sel[i])\n}\n\n\n5.3.1 Plotting\n\ngcs_den_sel_plots = list()\nfor (i in 1:length(gcs_d_sel)){\n  gcs_den_sel_plots[[i]] = ggplot2::ggplot(gcs_d_sel[[i]]) +\n    ggplot2::aes(x = sec,\n                 y = density) +\n    ggplot2::geom_line() \n}\n\n# let's plot a polygons 1-4 and 5-8\ngridExtra::grid.arrange(gcs_den_sel_plots[[1]], gcs_den_sel_plots[[2]], layout_matrix = rbind(c(1,2)))"
  },
  {
    "objectID": "density.html#comparison",
    "href": "density.html#comparison",
    "title": "5  Density",
    "section": "5.7 Comparison",
    "text": "5.7 Comparison\n\n5.7.1 Global\n\ndensity_comp = gcs_density + \n  # ggplot2::ggplot(jps_grouped) +\n  ggplot2::geom_line(data = jps_d,\n                     color = \"red\")\n\n\n\nprint(\"GCS mean density value\")\ngcs_d |> dplyr::group_by(sec) |> dplyr::pull(density) |> mean()\nprint(\"JPS mean density value\")\njps_d |> dplyr::group_by(sec) |> dplyr::pull(density) |> mean()\n\nprint(\"GCS median density value\")\ngcs_d |> dplyr::group_by(sec) |> dplyr::pull(density) |> median()\nprint(\"JPS median density value\")\njps_d |> dplyr::group_by(sec) |> dplyr::pull(density) |> median()\n\n[1] “GCS mean density value” [1] 0.02354127\n[1] “JPS mean density value” [1] 0.04464389\n[1] “GCS median density value” [1] 0.02566038\n[1] “JPS median density value” [1] 0.04566038\n\n\n5.7.2 Divided\n\ndensity_div_comp = list()\nfor (i in 1:length(gcs_den_div_plots)) {\n  density_div_comp[[i]] = gcs_den_div_plots[[i]] + \n  ggplot2::geom_line(data = jps_d_div[[i]],\n                     color = \"red\")\n}\n\ngridExtra::grid.arrange(density_div_comp[[1]], density_div_comp[[2]], density_div_comp[[3]], density_div_comp[[4]], layout_matrix = rbind(c(1,2),c(3,4)))\n\n\n\n\n5.7.3 Selected\n\nflow_sel_comp = list()\nfor (i in 1:length(gcs_flow_zones_plots)) {\n  flow_sel_comp[[i]] = gcs_flow_zones_plots[[i]] + \n  ggplot2::geom_line(data = jps_joined_grouped_zones[[i]],\n                     color = \"red\")\n}\n\ngridExtra::grid.arrange(flow_sel_comp[[1]], flow_sel_comp[[2]], layout_matrix = rbind(c(1,2)))"
  },
  {
    "objectID": "density.html#selected",
    "href": "density.html#selected",
    "title": "4  Density",
    "section": "4.8 Selected",
    "text": "4.8 Selected\n\nflow_sel_comp = list()\nfor (i in 1:length(gcs_flow_zones_plots)) {\n  flow_sel_comp[[i]] = gcs_flow_zones_plots[[i]] + \n  ggplot2::geom_line(data = jps_joined_grouped_zones[[i]],\n                     color = \"red\")\n}\n\ngridExtra::grid.arrange(flow_sel_comp[[1]], flow_sel_comp[[2]], layout_matrix = rbind(c(1,2)))"
  },
  {
    "objectID": "density.html#global-jps",
    "href": "density.html#global-jps",
    "title": "5  Density",
    "section": "5.4 2.1 Global (JPS)",
    "text": "5.4 2.1 Global (JPS)\n\n# group by seconds and then measure density\njps_d = traj1_sf |> \n  sf::st_drop_geometry() |> \n  dplyr::mutate(sec = FR/8) |>  # 1 sec = 8 frames\n  dplyr::group_by(sec) |> \n  dplyr::summarise(n = dplyr::n(),\n                   sec = sec) |> \n  dplyr::mutate(\n    density = n / gcs_area\n  )\n\ngcs_d |> head()\n\n\n5.4.1 Plotting\n\njps_density = ggplot2::ggplot(jps_d)+\n  ggplot2::aes(x = sec,\n               y = density)+\n  ggplot2::geom_line()\n\nprint(jps_density)"
  },
  {
    "objectID": "density.html#divided-jps",
    "href": "density.html#divided-jps",
    "title": "5  Density",
    "section": "5.5 2.2 Divided (JPS)",
    "text": "5.5 2.2 Divided (JPS)\n\n# add area as a new column\njps_den_div = list()\nfor (i in 1:length(jps_joined_grouped)){\n  jps_den_div[[i]] = jps_joined_grouped[[i]] |> dplyr::mutate(area = gcs_area_div[i])\n}\n\n\n# find density for each group in each list\njps_d_div = list()\nfor (i in 1:length(gcs_area_div)){\n  jps_d_div[[i]] = jps_den_div[[i]] |> dplyr::mutate(density = n / gcs_area_div[i])\n}\n\n\n5.5.1 Plotting\n\njps_den_div_plots = list()\nfor (i in 1:length(jps_d_div)){\n  jps_den_div_plots[[i]] = ggplot2::ggplot(jps_d_div[[i]]) +\n    ggplot2::aes(x = sec,\n                 y = density) +\n    ggplot2::geom_line() \n}\n\n# let's plot a polygons 1-4 \ngridExtra::grid.arrange(jps_den_div_plots[[1]], jps_den_div_plots[[2]], jps_den_div_plots[[3]], jps_den_div_plots[[4]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "density.html#selected-jps",
    "href": "density.html#selected-jps",
    "title": "5  Density",
    "section": "5.6 2.3 Selected (JPS)",
    "text": "5.6 2.3 Selected (JPS)\n\n# add area as a new column\njps_den_sel = list()\nfor (i in 1:length(jps_joined_zones)){\n  jps_den_sel[[i]] = jps_joined_grouped_zones[[i]] |> dplyr::mutate(area = gcs_area_sel[i])\n}\n\n\n# find density for each group in each list\njps_d_sel = list()\nfor (i in 1:length(jps_joined_zones)){\n  jps_d_sel[[i]] = jps_den_sel[[i]] |> dplyr::mutate(density = n / gcs_area_sel[i])\n}\n\n\n5.6.1 Plotting\n\njps_den_sel_plots = list()\nfor (i in 1:length(jps_d_sel)){\n  jps_den_sel_plots[[i]] = ggplot2::ggplot(jps_d_sel[[i]]) +\n    ggplot2::aes(x = sec,\n                 y = density) +\n    ggplot2::geom_line() \n}\n\n# let's plot a polygons 1-4 \ngridExtra::grid.arrange(jps_den_sel_plots[[1]], jps_den_sel_plots[[2]], layout_matrix = rbind(c(1,2)))"
  },
  {
    "objectID": "fd.html",
    "href": "fd.html",
    "title": "7  Fundamental diagrams",
    "section": "",
    "text": "The aim of this chapter is to plot fundamental diagrams (speed ~ density) and compare them between JPS and GCS.\nA fundamental diagram denotes to the linear relationship between average speed (or velocity) and density (or flow) of an agent, usually vehicles or pedestrians.\nDensity = N/Area\nSpeed(av) = sum(agent distance per frame)/N\nN = number of agents\nArea = an area in which agents are counted\nIt should be noted that fundamental diagrams may be slightly influenced by different measurement methods (Zhang et al., 2011). However, the aim of this chapter is not to compare different methods but rather understand the extent to which simulated (JPS) data reflects real-life GCS data. Therefore, the focus in this chapter is on classical density and average speed.\nNote 1: GCS has distance/speed per frame data. You can find out how it was acquired following this R script: https://github.com/GretaTimaite/pedestrian_simulation/blob/main/gcs_speed.R"
  },
  {
    "objectID": "fd.html#global-gcs",
    "href": "fd.html#global-gcs",
    "title": "7  Fundamental diagrams",
    "section": "7.1 1.1 Global (GCS)",
    "text": "7.1 1.1 Global (GCS)\nThis builds on the previous chapter on density, hence density part will be skipped. Instead, let’s move to finding out average speed per frame.\n\n# average speed per frame\ngcs_speed1 = gcs_sf_s |> \n  dplyr::group_by(sec) |> \n  dplyr::summarise(n = dplyr::n()) \ngcs_speed2 = gcs_sf_s |> \n  dplyr::mutate(dist = as.numeric(dist)) |> \n  dplyr::filter(dist != 0) |> # filter our starting points (ie the rows that have dist = 0)\n  dplyr::group_by(sec) |> \n  dplyr::summarise(dist_sum = sum(dist)) |>  # summing up the total distance of agents in a group\n  sf::st_drop_geometry() # drop geometry column\ngcs_speed = dplyr::left_join(gcs_speed1, gcs_speed2) |> \n  dplyr::mutate(speed_av = dist_sum/n) # average speed (see formula at the start of the notebook)\ngcs_speed_joined = dplyr::left_join(gcs_speed, gcs_d)"
  },
  {
    "objectID": "fd.html#plotting",
    "href": "fd.html#plotting",
    "title": "7  Fundamental diagrams",
    "section": "7.2 Plotting",
    "text": "7.2 Plotting\n\ngcs_fd = ggplot2::ggplot(data = gcs_speed_joined,\n                ggplot2::aes(x = density,\n                            y = speed_av))+\n  ggplot2::geom_point()"
  },
  {
    "objectID": "fd.html#divided-gcs",
    "href": "fd.html#divided-gcs",
    "title": "7  Fundamental diagrams",
    "section": "7.3 1.2 Divided (GCS)",
    "text": "7.3 1.2 Divided (GCS)\nTo find out how density has been measured, see “Density” chapter.\n\n# first create a list to store our new datasets \ngcs_fd_div = list()\nfor (i in 1:lengths(gcs_div_sf)){\n  gcs_fd_div[[i]] = gcs_sf_s[gcs_div_sf[i,], op = sf::st_intersects] \n}\n\n\n# a list with dataframes (denoting to different polygons) containing average speed of agents per frame\ngcs_speed_div = list()\nfor (i in 1:lengths(gcs_div_sf)){\n  gcs_speed_div[[i]] = gcs_fd_div[[i]] |> \n    dplyr::mutate(dist = as.numeric(dist)) |> # turn character into numeric\n    dplyr::filter(dist != 0) |> # filter out agent starting points (eg distance = 0)\n    dplyr::group_by(sec) |> \n    dplyr::summarise(n = dplyr::n(), # number of agents per frame\n                     dist_sum = sum(dist), # total sum\n                     speed_av = dist_sum / n) # average speed\n}\n\n\n# join dataframes in `gcs_speed_div` and `gcs_speed_div` lists accordingly (will help when plotting)\ngcs_fd_joined = list()\nfor (i in 1:length(gcs_fd_div)){\n  gcs_fd_joined[[i]] = dplyr::left_join(gcs_speed_div[[i]] |> sf::st_drop_geometry(),\n                                    gcs_d_div[[i]] |> sf::st_drop_geometry())\n}\n\n\n7.3.1 Plotting\n\ngcs_div_plots = list()\nfor (i in 1:length(gcs_fd_joined)){\n  gcs_div_plots[[i]] = ggplot2::ggplot(gcs_fd_joined[[i]]) +\n    ggplot2::aes(x = density,\n                 y = speed_av) +\n    ggplot2::geom_point() \n  # print(plots_den)\n}\ngridExtra::grid.arrange(gcs_div_plots[[1]], gcs_div_plots[[2]], gcs_div_plots[[3]], gcs_div_plots[[4]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "fd.html#selected-gcs",
    "href": "fd.html#selected-gcs",
    "title": "7  Fundamental diagrams",
    "section": "7.4 1.3 Selected (GCS)",
    "text": "7.4 1.3 Selected (GCS)\n\n# first create a list to store our new datasets \ngcs_fd_sel = list()\nfor (i in 1:length(zones)){\n  gcs_fd_sel[[i]] = gcs_sf_s[gcs_div_sf[i,], op = sf::st_intersects] \n}\n\n\n# a list with dataframes (denoting to different polygons) containing average speed of agents per frame\ngcs_speed_sel = list()\nfor (i in 1:lengths(zones)){\n  jps_speed_sel[[i]] = gcs_fd_sel[[i]] |> \n    dplyr::mutate(dist = as.numeric(dist)) |> # turn character into numeric\n    dplyr::filter(dist != 0) |> # filter out agent starting points (eg distance = 0)\n    dplyr::group_by(sec) |> \n    dplyr::summarise(n = dplyr::n(), # number of agents per frame\n                     dist_sum = sum(dist), # total sum\n                     speed_av = dist_sum / n) # average speed\n}\n\n\n# join lists accordingly (will help when plotting)\ngcs_fd_joined = list()\nfor (i in 1:length(zones)){\n  gcs_fd_joined[[i]] = dplyr::left_join(gcs_speed_div[[i]] |> sf::st_drop_geometry(),\n                                    gcs_d_div[[i]] |> sf::st_drop_geometry())\n}\n\n\n7.4.1 Plotting\n\ngcs_sel_plots = list()\nfor (i in 1:length(gcs_fd_joined)){\n  gcs_sel_plots[[i]] = ggplot2::ggplot(gcs_fd_joined[[i]]) +\n    ggplot2::aes(x = density,\n                 y = speed_av) +\n    ggplot2::geom_point() \n  # print(plots_den)\n}\n\ngridExtra::grid.arrange(gcs_sel_plots[[1]], gcs_sel_plots[[2]], layout_matrix = rbind(c(1,2)))"
  },
  {
    "objectID": "fd.html#global-jps",
    "href": "fd.html#global-jps",
    "title": "7  Fundamental diagrams",
    "section": "7.5 2.1 Global (JPS)",
    "text": "7.5 2.1 Global (JPS)\nWe don’t have dist column in our traj1 dataframe. Thus, we will need to derive it. We will measure speed per secon.\nThis builds on the previous chapter on density, hence density part will be skipped. Instead, let’s move to finding out average speed per second.\n\n# average speed per frame\njps_speed1 = jps_dist_df |> \n  dplyr::mutate(sec = FR / 8) |> \n  dplyr::group_by(sec) |> \n  dplyr::summarise(n = dplyr::n(),\n                   FR = FR,\n                   ID = ID) \njps_speed2 = jps_dist_df |> \n  sf::st_drop_geometry() |> # drop geometry column\n  dplyr::mutate(sec = FR / 8) |> \n  dplyr::mutate(dist = as.numeric(dist)) |> \n  dplyr::filter(dist != 0) |> # filter our starting points (ie the rows that have dist = 0)\n  dplyr::group_by(sec) |> \n  dplyr::summarise(dist_sum = sum(dist),\n                   FR = FR,\n                   ID = ID)   # summing up the total distance of agents in a group\njps_speed = dplyr::left_join(jps_speed1, jps_speed2) |> \n  dplyr::mutate(speed_av = dist_sum/n) # average speed (see formula at the start of the notebook)\n\njps_d_group_sec = jps_d |> \n  dplyr::group_by(sec) |> \n  dplyr::summarise(n = dplyr::n(),\n                   density = density)\njps_speed_joined = dplyr::left_join(jps_speed, jps_d_group_sec)"
  },
  {
    "objectID": "fd.html#plotting-3",
    "href": "fd.html#plotting-3",
    "title": "7  Fundamental diagrams",
    "section": "7.6 Plotting",
    "text": "7.6 Plotting\n\njps_fd = ggplot2::ggplot(data = jps_speed_joined,\n                ggplot2::aes(x = density,\n                            y = speed_av))+\n  ggplot2::geom_point()"
  },
  {
    "objectID": "fd.html#divided-jps",
    "href": "fd.html#divided-jps",
    "title": "7  Fundamental diagrams",
    "section": "7.7 Divided (JPS)",
    "text": "7.7 Divided (JPS)\nTo find out how density has been measured, see “Density” chapter.\n\n# first create a list to store our new datasets \n\n# turn df into an sf object\njps_dist_sf = jps_dist_df |> \n  sf::st_as_sf(coords = c(\"x_coord\", \"y_coord\"))\n\njps_fd_div = list()\nfor (i in 1:lengths(gcs_div_sf)){\n  jps_fd_div[[i]] = jps_dist_sf[gcs_div_sf[i,], op = sf::st_intersects] \n}\n\n\n# a list with dataframes (denoting to different polygons) containing average speed of agents per frame\njps_speed_div = list()\nfor (i in 1:lengths(gcs_div_sf)){\n  jps_speed_div[[i]] = jps_fd_div[[i]] |> \n    dplyr::mutate(sec = FR / 8) |> \n    dplyr::mutate(dist = as.numeric(dist)) |> # turn character into numeric\n    dplyr::filter(dist != 0) |> # filter out agent starting points (eg distance = 0)\n    dplyr::group_by(sec) |> \n    dplyr::summarise(n = dplyr::n(), # number of agents per frame\n                     dist_sum = sum(dist), # total sum\n                     speed_av = dist_sum / n) # average speed\n}\n\n\n# join dataframes in `gcs_speed_div` and `gcs_speed_div` lists accordingly (will help when plotting)\njps_fd_joined = list()\nfor (i in 1:length(jps_fd_div)){\n  jps_fd_joined[[i]] = dplyr::left_join(jps_speed_div[[i]] |> sf::st_drop_geometry(),\n                                    jps_d_div[[i]] |> sf::st_drop_geometry())\n}\n\n\n7.7.1 Plotting\n\njps_div_plots = list()\nfor (i in 1:length(jps_fd_joined)){\n  jps_div_plots[[i]] = ggplot2::ggplot(jps_fd_joined[[i]]) +\n    ggplot2::aes(x = density,\n                 y = speed_av) +\n    ggplot2::geom_point() \n  # print(plots_den)\n}\ngridExtra::grid.arrange(jps_div_plots[[1]], jps_div_plots[[2]], jps_div_plots[[3]], jps_div_plots[[4]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "fd.html#selected-jps",
    "href": "fd.html#selected-jps",
    "title": "7  Fundamental diagrams",
    "section": "7.8 Selected (JPS)",
    "text": "7.8 Selected (JPS)\n\n# first create a list to store our new datasets \njps_fd_sel = list()\nfor (i in 1:length(zones)){\n  jps_fd_sel[[i]] = jps_dist_sf[zones[i], op = sf::st_intersects] \n}\n\n\n# a list with dataframes (denoting to different polygons) containing average speed of agents per frame\njps_speed_sel = list()\nfor (i in 1:length(zones)){\n  jps_speed_sel[[i]] = jps_fd_sel[[i]] |> \n    dplyr::mutate(sec = FR / 8) |> \n    dplyr::mutate(dist = as.numeric(dist)) |> # turn character into numeric\n    dplyr::filter(dist != 0) |> # filter out agent starting points (eg distance = 0)\n    dplyr::group_by(sec) |> \n    dplyr::summarise(n = dplyr::n(), # number of agents per frame\n                     dist_sum = sum(dist), # total sum\n                     speed_av = dist_sum / n) # average speed\n}\n\n\n# join lists accordingly (will help when plotting)\njps_fd_joined = list()\nfor (i in 1:length(zones)){\n  jps_fd_joined[[i]] = dplyr::left_join(jps_speed_sel[[i]] |> sf::st_drop_geometry(),\n                                    jps_d_sel[[i]] |> sf::st_drop_geometry())\n}\n\n\n7.8.1 Plotting\n\njps_sel_plots = list()\nfor (i in 1:length(jps_fd_joined)){\n  jps_sel_plots[[i]] = ggplot2::ggplot(jps_fd_joined[[i]]) +\n    ggplot2::aes(x = density,\n                 y = speed_av) +\n    ggplot2::geom_point() \n  # print(plots_den)\n}\n\ngridExtra::grid.arrange(jps_sel_plots[[1]], jps_sel_plots[[2]], layout_matrix = rbind(c(1,2)))"
  },
  {
    "objectID": "fd.html#global",
    "href": "fd.html#global",
    "title": "7  Fundamental diagrams",
    "section": "8.1 Global",
    "text": "8.1 Global\n\n#fd_comp = gcs_fd +\n  ggplot2::geom_point(data = jps_speed_joined,\n                      color = \"red\")\n\n\n## Divided\n\nfd_div_comp = list()\nfor (i in 1:length(gcs_fd_div)) {\n  fd_div_comp[[i]] = gcs_div_plots[[i]] + \n  ggplot2::geom_point(data = jps_fd_joined[[i]],\n                     color = \"red\")\n}\n\ngridExtra::grid.arrange(fd_div_comp[[1]], fd_div_comp[[2]], fd_div_comp[[3]], fd_div_comp[[4]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "fd.html#selected",
    "href": "fd.html#selected",
    "title": "7  Fundamental diagrams",
    "section": "8.2 Selected",
    "text": "8.2 Selected\n\ngcs_fd_div_plots+\n  ggplot2::geom_point(data = jps_fd_joined,\n                      color = \"red\")\n\n\nfd_sel_comp = list()\nfor (i in 1:length(gcs_fd_div_plots)) {\n  fd_sel_comp[[i]] = gcs_fd_div_plots[[i]] + \n  ggplot2::geom_point(data = jps_fd_joined[[i]],\n                     color = \"red\")\n}\n\ngridExtra::grid.arrange(fd_sel_comp[[1]], fd_sel_comp[[2]], layout_matrix = rbind(c(1,2),c(3,4)))"
  },
  {
    "objectID": "speed.html",
    "href": "speed.html",
    "title": "6  Speed",
    "section": "",
    "text": "8 JPS Speed\n\n# get data\njps = read.table(\"/Users/gretatimaite/Desktop/pedestrian_simulation/final_results/8_frame/1/traj.txt\",\n                 col.names = c(\"ID\",    \"FR\",   \"X\",    \"Y\",    \"Z\",    \"A\",    \"B\",    \"ANGLE\",    \"COLOR\"))\n\njps_sf = jps |> \n  sf::st_as_sf(coords = c(\"X\", \"Y\"))\n\n## now we'll create a list of dataframes for each agent\n# first, let's find out the number of unique agents as this will be the number of dataframes in the list\nunique_ids = jps_sf |> dplyr::pull(ID) |> unique() |> sort()\n\n# create an empty list to store DFs\nagent_list = list()\n# create a loop\nfor (i in 1:length(unique_ids)){\n  agent_list[[i]] = jps_sf |> # iterate through frames_sf\n    dplyr::filter(ID %in% unique_ids[i]) # filter frames_sf by a unique ID\n}\n\n## sanity check\nidentical(agent_list[[30]],\n          jps_sf |> dplyr::filter(ID %in% unique_ids[30]))\n# >TRUE\n\n\n## Now we will create a matrix of distances for each frame of a given agent. \n# It will be used later in a function to extract the distances sequentially (from frame 1 to frame 2 to frame 3, etc)\n\ndistance_matrix_list = list()\n# system.time( # to measure how long it takes to run \nfor (i in 1:length(agent_list)){\n  distance_matrix_list[[i]] = sf::st_distance(agent_list[[i]])\n}\n# )\n\n# create a function that accepts a list of matrices\ndist_function = function(list_matrix = list()){ # accepts lists\n  dist_list = list() # empty list to store new lists\n  for (i in 1:length(list_matrix)){ # reiteration over the length of a list\n    k = i # initialisation of a matrix row\n    j = k + 1  # initialisation of a matrix column, it needs to be + 1 compared to the row as otherwise we will get distance equal to 0 \n    # (there's no distance traveled from, e.g. frame 2 to frame 2)\n    if (j <= ncol(list_matrix)){ # columns should not exceed the number of columns of a matrix (looping (out of bounds) error might be given otherwise)\n      dist_list[[i]] = list_matrix[k,j] # for each `i` list extract matrix values at row k and column j \n    }\n    else {\n      break # break if j is above number of columns of a matrix\n    }\n  }\n  return(dist_list)\n}\n\n# an empty list for distance vectors\ndistance_list = list()\n# loop over `distance_matrix_list` and apply a `dist_function()`\n# system.time( # to measure how long it takes to run \nfor (i in 1:length(distance_matrix_list)){\n  distance_list[[i]] = distance_matrix_list[[i]] |> \n    dist_function() |> # apply the new function\n    unlist() |> \n    as.data.frame() # create a dataframe (will be useful in later steps)\n  colnames(distance_list[[i]]) = \"dist\" # rename a column\n}\n# )\n\n# NOTE: each list is shorter by 1 element compared to the original input list because of initialisation starting at 1, thus capturing the distance between frame 1 and 2. \n# In other words, the function omits the starting point at which an agent.\n\n## testing\n# here we'll check that the function works as it should.\n\ndistance_list[[5]][1] # agent 5's traveled distance from frame 1 to 2\n#> [1] 0.1474067\n# finding distance manually\nsf::st_distance(agent_list[[5]][1,3], # frame 1 of agent 5\n                agent_list[[5]][2,3]) # frame 2 of agent 5\n#> [1,] 0.1474067\ndistance_matrix_list[[5]][2,1] # second row in matrix 1 ([1,1] would return 0 as there's the distance from frame 1 to frame 1 equals to 0) of agent 5.\n#> [1] 0.1474067\n\n## it's time to join distance_list to agents_list\n# NOTE: our lists are of unequal row lengths, hence we will have to do two intermediate steps\n# first let's create a list to store joined lists\njps_dist_list = list()\n# a list to store values of a shorter (intermediate) list of dataframes\njps_list_new = list()\n# create a loop\n# first we will create an intermediate list of dataframes\nfor (i in 1:length(agent_list)){\n  jps_list_new[[i]] = rbind(data.frame(\"dist\" = 0),\n                             distance_list[[i]]) # adding a new row on top of the dataframes in the distance_list, \n  # so their length matches the length of DFs in the agent_list\n  jps_dist_list[[i]] = cbind(agent_list[[i]],\n                               jps_list_new[[i]]) # joining dataframes by column\n}\n\n# check\njps_dist_list[[1]]\n\n\n# save as RDS\nsaveRDS(jps_dist_list,\n        file = \"jps_dist_list.rds\")\n\n\n# lists into a single df\n\njps_dist_sf = as.data.frame(do.call(rbind,  jps_dist_list))\n\njps_dist_df = jps_dist_sf  |> \n    dplyr::mutate(x_coord = unlist(purrr::map(jps_dist_sf$geometry,1)),\n           y_coord = unlist(purrr::map(jps_dist_sf$geometry,2))) |> \n  dplyr::select(-geometry)\n\n# save as csv\n# write.csv(jps_dist_df,\n#           \"jps_dist_df\")"
  },
  {
    "objectID": "voronoi.html",
    "href": "voronoi.html",
    "title": "7  Voronoi",
    "section": "",
    "text": "deldir_pol = readRDS(\"/Users/gretatimaite/Desktop/pedestrian_simulation/deldir_pol.RDS\")\n\n\n# first let's \"borrow\" some density code from the previous chaper\n\nmatrix_walls = matrix(c(0,0,0,50*14,53*14,50*14,53*14, 0,0,0),\n                      ncol = 2,\n                      byrow = TRUE)\nmatrixlist_walls = list(matrix_walls)\npolygon_walls = sf::st_polygon(matrixlist_walls)\n\n# divide gcs polygon by creating a grid\ngcs_div = sf::st_make_grid(polygon_walls, \n                           n = 2,\n                           what = \"polygons\")\n# convert gcs_div to an sf object\ngcs_div_sf = gcs_div |> \n  sf::st_as_sf() |> \n  dplyr::rename(geom = x)\n\n\n# function \n\ngcs_deldir_fun = function(gcs = list(),\n                          deldir_pol = list()){\n  sf::st_intersection(gcs,\n                      deldir_pol)\n}\n\n\ngcs_deldir1 = list()\ngcs_deldir2 = list()\ngcs_deldir3 = list()\ngcs_deldir4 = list()\n  for (k in 1:length(deldir_pol)){\n    if (k > 43 &\n        k < length(deldir_pol) + 1){\n      gcs_deldir1[[k]] = gcs_deldir_fun(gcs = gcs_div_sf[1,],\n                                       deldir_pol = deldir_pol[[k]])\n      gcs_deldir2[[k]] = gcs_deldir_fun(gcs = gcs_div_sf[2,],\n                                       deldir_pol = deldir_pol[[k]])\n      gcs_deldir3[[k]] = gcs_deldir_fun(gcs = gcs_div_sf[3,],\n                                       deldir_pol = deldir_pol[[k]])\n      gcs_deldir4[[k]] = gcs_deldir_fun(gcs = gcs_div_sf[4,],\n                                       deldir_pol = deldir_pol[[k]])\n    }\n  }\n\n\n# Now let's figure out how many tiles are in each polygon\n# number of tiles (rows) in each dataframe in gcs_deldir indicates the number of agents\n# this number will be divided by the estimates area of a polygon\n\n# find out the area size of each polygon\ngcs_area = list()\nfor (i in 1:lengths(gcs_div_sf)){\n  gcs_area[[i]] = sf::st_area(gcs_div_sf[[i]] / 14) # convert to metres\n  # print(gcs_area)\n}\n# make it a vector\ngcs_area = gcs_area |>\n  unlist() |>\n  as.vector()\n\n\n# plot 1\nvoronoi_density1_temp = vector()\nvoronoi_density1 = data.frame()\nfor (i in 1:length(gcs_deldir1)){\n  if(is.null(gcs_deldir1[[i]]) == FALSE){\n    voronoi_density1_temp[i] = nrow(gcs_deldir1[[i]]) / gcs_area[1]\n    voronoi_density1 = as.data.frame(\"x\" = voronoi_density1_temp) |> \n      dplyr::mutate(frame = dplyr::row_number(),\n                    sec = frame / 25)\n    colnames(voronoi_density1) = c(\"density\", \"frame\", \"sec\")\n  }\n  }\n\nggplot2::ggplot(voronoi_density1)+\n  ggplot2::aes(x = sec,\n               y = density)+\n  ggplot2::geom_line() +\n  ggplot2::geom_line(data = gcs_d_div[[1]], color = \"red\")"
  },
  {
    "objectID": "flow.html#global-flow-gcs",
    "href": "flow.html#global-flow-gcs",
    "title": "4  Flow",
    "section": "4.1 1.1 Global flow (GCS)",
    "text": "4.1 1.1 Global flow (GCS)\n\n# now let's create a new column for seconds\n# 1 second = 25 frames\ngcs_sf_s = gcs_sf |> \n  dplyr::mutate(sec = as.numeric(frame) / 25)\n\n# group df by seconds\ngcs_grouped = gcs_sf_s |> \n  sf::st_drop_geometry() |> #drop geometry as it's not needed here\n  dplyr::group_by(sec) |> # group by seconds\n  dplyr::summarise(n = dplyr::n()) # summarise \n\ngcs_grouped |> \n  head()\n\n\n4.1.1 Plotting\n\ngcs_flow_plot = ggplot2::ggplot(gcs_grouped) +\n  ggplot2::aes(x = sec,\n               y = n) +\n  ggplot2::geom_line()\n\nWe could add add additional information by adding lines indicating mean and median for seconds and number of agents, but I’m not sure it tells us much…\n\n# let's calculate mean and median values of n to add to the plot\ngcs_mean_s = gcs_sf_s$sec |> mean()\ngcs_median_s = gcs_sf_s$sec |> median()\ngcs_mean_n = gcs_grouped$n |> mean()\ngcs_median_n = gcs_grouped$n |> median()\n\nggplot2::ggplot(gcs_grouped) +\n  ggplot2::aes(x = sec,\n               y = n) +\n  ggplot2::geom_line() +\n  ggplot2::geom_vline(xintercept = gcs_mean_s,\n                      col = \"red\") +\n  ggplot2::geom_text(ggplot2::aes(x=gcs_mean_s+5, label=paste0(\"Mean\\n\",round(gcs_mean_s,2)), y=80)) +\n  ggplot2::geom_vline(xintercept = gcs_median_s, \n                      col = \"blue\") +\n  ggplot2::geom_hline(yintercept = gcs_mean_n,\n                      col = \"red\") +\n  ggplot2::geom_hline(yintercept = gcs_median_n,\n                      col = \"blue\")"
  }
]